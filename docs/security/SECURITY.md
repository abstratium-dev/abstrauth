# Security Implementation

This document describes the JWT-based security implementation for the abstrauth OAuth2 authorization server.

## Overview

The application uses **Quarkus SmallRye JWT** for securing REST endpoints with role-based access control (RBAC). JWT tokens are signed using PS256 (RSA-PSS with SHA-256) algorithm.

## Architecture

### Token Generation
- Tokens are generated by the OAuth2 authorization flow in `TokenResource`
- Private key is configured via `smallrye.jwt.sign.key` property
- Algorithm: PS256 (RSA-PSS with SHA-256)
- Issuer: `https://abstrauth.abstratium.dev`

### Token Verification
- Tokens are verified using the public key extracted from the private key
- Public key is configured via `mp.jwt.verify.publickey` property
- Issuer validation ensures tokens are from the correct authorization server
- Signature validation ensures token integrity

### Role-Based Access Control
- Roles are extracted from the `groups` claim in the JWT
- The `@RolesAllowed` annotation protects endpoints
- Role naming convention: `<client_id>_<role_name>` (e.g., `abstratium-abstrauth_manage-clients`)
- Universal roles (e.g., `user`) are automatically prefixed with the client ID when added to tokens

### Default Roles

All users receive the "user" role automatically, when their account is created. That role is for the default client named `abstratium-abstrauth`. That way, if the sign in they can see their roles for each client that they have been added to.

**Role Formats**:
- `user` - Universal role, auto-prefixed with client ID (becomes `abstratium-abstrauth_user`)
- `abstratium-abstrauth_manage-clients` - Client-specific role, only added if client ID matches

## Configuration

### Signup Control

The `allow.signup` configuration property controls whether new user registration is allowed:

```properties
%dev.allow.signup=true
%test.allow.signup=true
%prod.allow.signup=false
```

**Important**: Regardless of this setting, signup is **always enabled** when there are no accounts in the database. This ensures the first user (administrator) can always be created during initial setup.

**Security Rationale**:
- In production, signup should typically be disabled (`allow.signup=false`)
- The first user to register receives the `abstratium-abstrauth_admin` role
- After initial registration, the user should check the accounts list to verify no other accounts were created simultaneously
- After the first account is created, only administrators should be able to add new users (via future admin APIs)
- This prevents unauthorized account creation on publicly accessible instances
- The automatic first-user exception ensures the system is always accessible for initial setup

### Key Management

The application uses a single RSA key pair for signing and verification:

**Private Key** (for signing tokens):
```properties
%dev.smallrye.jwt.sign.key=<base64-encoded-private-key>
%test.smallrye.jwt.sign.key=${%dev.smallrye.jwt.sign.key}
%prod.smallrye.jwt.sign.key=SET-USING-ENV-VAR
```

**Public Key** (for verifying tokens):
```properties
%dev.mp.jwt.verify.publickey=<base64-encoded-public-key>
%test.mp.jwt.verify.publickey=${%dev.mp.jwt.verify.publickey}
%prod.mp.jwt.verify.publickey=SET-USING-ENV-VAR
```

### Extracting Public Key

To extract the public key from the private key, use the provided script:

```bash
./extract-public-key.sh
```

This will output the public key in base64 format for use in `application.properties`.

### JWT Verification Settings

```properties
# Algorithm used for signature verification
mp.jwt.verify.publickey.algorithm=PS256

# Expected issuer claim value
mp.jwt.verify.issuer=https://abstrauth.abstratium.dev

# Map 'groups' claim to roles for @RolesAllowed
smallrye.jwt.path.groups=groups
smallrye.jwt.claims.groups=groups
```

## Protected Endpoints

### `/api/clients` - OAuth Client Management

**Protection**: `@RolesAllowed("abstratium-abstrauth_manage-clients")`

**Required Role**: `abstratium-abstrauth_manage-clients`

**Behavior**:
- **No token**: Returns HTTP 401 Unauthorized
- **Invalid token**: Returns HTTP 401 Unauthorized
- **Valid token without required role**: Returns HTTP 403 Forbidden
- **Valid token with required role**: Returns HTTP 200 OK with client list

### `/api/signup` - User Registration

**Protection**: `@PermitAll`

**Behavior**:
- Publicly accessible (no authentication required)
- Signup authorization is managed by `AuthorizationService.isSignupAllowed()`
- Signup is **always allowed** when there are no accounts in the database (first user setup)
- After the first account exists, signup is controlled by the `allow.signup` configuration property

**First User Admin Role**:
- The first account created (via native signup or federated login) automatically receives the `abstratium-abstrauth_admin` role
- This admin role enables access to administrative APIs (to be implemented)
- After registration, users should navigate to the accounts list page to verify no other accounts were created simultaneously during initial setup

## Angular HTTP Interceptor

The Angular frontend automatically adds JWT tokens to API requests via `authInterceptor`:

**Behavior**:
- Adds `Authorization: Bearer <token>` header to all `/api/*` requests
- Only adds token when user is authenticated (`authService.isAuthenticated()`)
- Does not modify requests to other paths (e.g., `/oauth2/*`, `/.well-known/*`)

**Implementation**: `src/main/webui/src/app/auth.interceptor.ts`

## Testing

### Backend Tests

Tests use `io.smallrye.jwt.build.Jwt` to generate test tokens:

```java
// Generate valid token with required roles
String token = Jwt.issuer("https://abstrauth.abstratium.dev")
    .upn("test@example.com")
    .groups(Set.of("abstratium-abstrauth_user", "abstratium-abstrauth_manage-clients"))
    .claim("email", "test@example.com")
    .claim("name", "Test User")
    .sign();

// Use token in request
given()
    .header("Authorization", "Bearer " + token)
    .when()
    .get("/api/clients")
    .then()
    .statusCode(200);
```

**Note**: In test environments, default roles (`user`, `manage-clients`) are automatically added to all tokens. Tests can override this by explicitly setting the `groups` claim.

### Test Coverage

The `ClientsResourceTest` includes:
- âœ… Returns 401 when no token is provided
- âœ… Returns 401 when invalid token is provided
- âœ… Returns 403 when valid token lacks required role
- âœ… Returns 200 when valid token with required role is provided
- âœ… All functional tests updated to use valid tokens

### Angular Tests

The Angular interceptor has comprehensive tests covering:
- âœ… Adds Authorization header to `/api/*` requests with JWT
- âœ… Does not add header when user is not authenticated
- âœ… Does not add header to non-API requests
- âœ… Handles token changes and signout correctly

## OAuth2 State Parameter and CSRF Protection

### What is CSRF in OAuth2?

**Cross-Site Request Forgery (CSRF)** in OAuth2 occurs when an attacker tricks a victim into completing an OAuth flow initiated by the attacker. This can lead to:
- Account linking attacks (victim's session linked to attacker's account)
- Data leakage (victim unknowingly uses attacker's account)
- Session hijacking

### How the State Parameter Prevents CSRF

The `state` parameter is a **cryptographically random string** that:
1. Is generated by the client before initiating OAuth flow
2. Is stored in the client's session storage
3. Is sent to the authorization server
4. Is returned unchanged in the callback
5. **Must be validated** by the client to ensure the callback matches the original request

**Attack Scenario Without State Validation:**
```
1. Attacker initiates OAuth: /oauth2/authorize?client_id=...&state=ATTACKER_STATE
2. Attacker captures authorization code from redirect
3. Attacker tricks victim to visit: https://victim-app.com/callback?code=ATTACKER_CODE
4. Victim's session gets linked to attacker's account
5. Victim unknowingly uses attacker's account, exposing data
```

**Protection With State Validation:**
```
1. Client generates random state: "abc123xyz"
2. Client stores in sessionStorage
3. Client initiates OAuth with state=abc123xyz
4. Authorization server returns: /callback?code=...&state=abc123xyz
5. Client validates: sessionStorage.state === callback.state
6. If mismatch â†’ reject (CSRF attack detected)
```

### Implementation Status

#### âœ… Server-Side (Secure)

**Native Login Flow:**
- State is stored in `AuthorizationRequest` entity
- State is validated when generating authorization code
- State is returned to client in redirect

**Federated Login Flow (Google):**
- State parameter contains the `AuthorizationRequest.id`
- Google callback validates state by looking up the authorization request
- Invalid state returns 400 Bad Request
- State is returned to client in final redirect

**Code References:**
- `AuthorizationResource.java` - Stores state in authorization request
- `GoogleCallbackResource.java` - Validates state parameter
- `FederatedLoginResource.java` - Uses request_id as state

#### âœ… Client-Side (Secure)

**Authorization Initiation:**
- Generates cryptographically random state (32 characters)
- Stores state in sessionStorage
- Sends state to authorization server

**Callback Validation:**
- Retrieves state from URL query parameter
- Compares with stored state in sessionStorage
- Rejects callback if state doesn't match
- Clears state from sessionStorage after validation

**Code References:**
- `authorize.component.ts` - Generates and stores state
- `auth-callback.component.ts` - Validates state parameter

### State Parameter Flow

```mermaid
sequenceDiagram
    participant SPA as Single Page App
    participant Storage as SessionStorage
    participant AuthServer as Auth Server
    participant Google as Google (IdP)

    Note over SPA: User clicks "Login"
    SPA->>SPA: Generate random state="abc123"
    SPA->>Storage: Store state="abc123"
    SPA->>AuthServer: GET /oauth2/authorize?state=abc123
    AuthServer->>AuthServer: Store state in AuthorizationRequest
    
    alt Native Login
        AuthServer->>SPA: Redirect with code & state=abc123
    else Federated Login
        AuthServer->>Google: Redirect with state=REQ_ID
        Google->>AuthServer: Callback with state=REQ_ID
        AuthServer->>AuthServer: Validate state=REQ_ID
        AuthServer->>SPA: Redirect with code & state=abc123
    end
    
    SPA->>Storage: Retrieve stored state
    SPA->>SPA: Validate: stored === received
    alt State Valid
        SPA->>AuthServer: Exchange code for token
    else State Invalid
        SPA->>SPA: Reject (CSRF detected)
    end
    SPA->>Storage: Clear state
```

### Additional CSRF Protections

1. **PKCE (Proof Key for Code Exchange)**:
   - Prevents authorization code interception
   - Code verifier stored in sessionStorage
   - Code challenge sent to authorization server
   - Server validates code_verifier matches code_challenge

2. **Short-Lived Authorization Codes**:
   - Codes expire after 10 minutes
   - Single-use only (marked as used after exchange)
   - Reduces window for CSRF attacks

3. **Redirect URI Validation**:
   - Server validates redirect_uri matches registered client
   - Prevents code leakage to attacker's domain

4. **SameSite Cookies**:
   - Refresh tokens use `SameSite=Lax` attribute
   - Prevents CSRF on token refresh endpoint

## Security Best Practices

### âœ… Implemented

1. **Token Signature Verification**: All tokens are cryptographically verified using RSA-PSS
2. **Issuer Validation**: Tokens must be issued by `https://abstrauth.abstratium.dev`
3. **Role-Based Access Control**: Fine-grained permissions using `@RolesAllowed`
4. **Proper HTTP Status Codes**: 401 for authentication failures, 403 for authorization failures
5. **Secure Key Management**: Private keys configured via environment variables in production
6. **Token Expiration**: Tokens include `exp` claim (handled by SmallRye JWT automatically)
7. **HTTPS in Production**: Recommended via reverse proxy configuration
8. **CSRF Protection**: State parameter validation in OAuth2 flows
9. **PKCE**: Proof Key for Code Exchange prevents authorization code interception
10. **Authorization Code Security**: Single-use, short-lived (10 minutes), validated redirect URIs
11. **Content Security Policy (CSP)**: Comprehensive CSP headers prevent XSS and code injection
12. **Security Headers**: X-Frame-Options, X-Content-Type-Options, Referrer-Policy, etc.
13. **Rate Limiting**: OAuth endpoints protected against brute-force and abuse attacks

### ðŸ”’ Production Deployment

For production deployment:

1. **Set environment variables**:
   ```bash
   export SMALLRYE_JWT_SIGN_KEY="<your-private-key>"
   export MP_JWT_VERIFY_PUBLICKEY="<your-public-key>"
   ```

2. **Generate production keys**:
   ```bash
   # Generate new RSA key pair
   openssl genpkey -algorithm RSA -out privateKey.pem -pkeyopt rsa_keygen_bits:2048
   
   # Extract public key
   openssl rsa -in privateKey.pem -pubout -out publicKey.pem
   
   # Convert to base64 (no headers/newlines)
   grep -v '^-----' privateKey.pem | tr -d '\n'
   grep -v '^-----' publicKey.pem | tr -d '\n'
   ```

3. **Use HTTPS**: Configure reverse proxy (nginx, Apache, etc.) to terminate TLS

4. **Rotate keys periodically**: Update keys and redeploy application

## Content Security Policy (CSP)

### What is CSP?

Content Security Policy is an HTTP header that helps prevent Cross-Site Scripting (XSS), clickjacking, and other code injection attacks by controlling which resources the browser is allowed to load.

### Current CSP Configuration

```
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' 'unsafe-inline'; 
  style-src 'self' 'unsafe-inline'; 
  img-src 'self' data: https:; 
  font-src 'self' data:; 
  connect-src 'self'; 
  frame-ancestors 'none'; 
  base-uri 'self'; 
  form-action 'self'
```

### CSP Directives Explained

| Directive | Value | Purpose |
|-----------|-------|---------|
| `default-src` | `'self'` | Default policy: only load resources from same origin |
| `script-src` | `'self' 'unsafe-inline'` | Allow scripts from same origin and inline scripts (Angular requires this) |
| `style-src` | `'self' 'unsafe-inline'` | Allow styles from same origin and inline styles (Angular requires this) |
| `img-src` | `'self' data: https:` | Allow images from same origin, data URIs, and HTTPS sources (for Google profile pictures) |
| `font-src` | `'self' data:` | Allow fonts from same origin and data URIs |
| `connect-src` | `'self'` | Allow AJAX/fetch requests only to same origin |
| `frame-ancestors` | `'none'` | Prevent page from being embedded in iframes (clickjacking protection) |
| `base-uri` | `'self'` | Restrict `<base>` tag to same origin |
| `form-action` | `'self'` | Forms can only submit to same origin |

### Additional Security Headers

The `SecurityHeadersFilter` also adds these headers:

- **X-Content-Type-Options: nosniff** - Prevents MIME type sniffing
- **X-Frame-Options: DENY** - Prevents clickjacking (backup for CSP)
- **X-XSS-Protection: 1; mode=block** - Legacy XSS protection for older browsers
- **Referrer-Policy: strict-origin-when-cross-origin** - Controls referrer information
- **Permissions-Policy** - Restricts browser features (geolocation, camera, etc.)
- **Strict-Transport-Security (HSTS)** - Forces HTTPS (enabled only in production)

### Customizing CSP

To customize the CSP policy, update `application.properties`:

```properties
# Disable CSP (not recommended)
security.csp.enabled=false

# Custom CSP policy
security.csp.policy=default-src 'self'; script-src 'self' https://trusted-cdn.com
```

### HSTS Configuration

HSTS (HTTP Strict Transport Security) forces browsers to only connect via HTTPS:

```properties
# HSTS is disabled by default (dev/test/e2e use HTTP)
security.hsts.enabled=false
security.hsts.max-age=31536000           # 1 year in seconds
security.hsts.include-subdomains=true    # Apply to all subdomains
security.hsts.preload=true               # Eligible for browser preload lists

# Automatically enabled in production
%prod.security.hsts.enabled=true
```

**Important:** Only enable HSTS when serving over HTTPS. Enabling HSTS on HTTP will break your application.

**HSTS Header Example (Production):**
```http
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

### CSP Violation Reporting (Future Enhancement)

To monitor CSP violations in production, add a `report-uri` directive:

```properties
security.csp.policy=default-src 'self'; ...; report-uri /api/csp-report
```

Then implement a `/api/csp-report` endpoint to log violations.

## Rate Limiting

### What is Rate Limiting?

Rate limiting restricts the number of requests a client can make to prevent:
- **Brute-force attacks** on authentication endpoints
- **Denial of Service (DoS)** attacks
- **Credential stuffing** attacks
- **API abuse**

### Current Rate Limit Configuration

**Default Limits:**
- **10 requests per minute** per IP address
- **5-minute ban** after exceeding limits
- Applied to OAuth and authentication endpoints only

**Protected Endpoints:**
- `/oauth2/authorize` - Authorization initiation
- `/oauth2/token` - Token exchange
- `/oauth2/callback/*` - OAuth callbacks
- `/oauth2/federated/*` - Federated login
- `/api/signup` - User registration
- `/api/signin` - User authentication

### Rate Limit Headers

Clients receive these headers in responses:

```http
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 7
X-RateLimit-Reset: 1733174400
```

- **X-RateLimit-Limit**: Maximum requests allowed in window
- **X-RateLimit-Remaining**: Requests remaining in current window
- **X-RateLimit-Reset**: Unix timestamp when the window resets

### Rate Limit Response

When rate limit is exceeded:

```http
HTTP/1.1 429 Too Many Requests
Retry-After: 300
Content-Type: text/plain

Rate limit exceeded. Too many requests from your IP address.
```

### Configuration

Customize rate limits in `application.properties`:

```properties
# Enable/disable rate limiting
rate-limit.enabled=true

# Maximum requests per window
rate-limit.oauth.max-requests=10

# Time window in seconds (60 = 1 minute)
rate-limit.oauth.window-seconds=60

# Ban duration in seconds after exceeding limits (300 = 5 minutes)
rate-limit.oauth.ban-duration-seconds=300
```

### Production Recommendations

For production, consider stricter limits:

```properties
%prod.rate-limit.oauth.max-requests=5
%prod.rate-limit.oauth.window-seconds=60
%prod.rate-limit.oauth.ban-duration-seconds=600
```

### IP Address Detection

The rate limiter detects client IP from:
1. **X-Forwarded-For** header (for requests behind reverse proxy)
2. **X-Real-IP** header (alternative proxy header)
3. **Remote address** (fallback)

**Important:** When deployed behind nginx or another reverse proxy, ensure the proxy sets the `X-Forwarded-For` header correctly.

### Nginx Configuration Example

```nginx
location / {
    proxy_pass http://localhost:8080;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
}
```

### Distributed Deployments

**Note:** The current implementation uses in-memory storage, suitable for single-instance deployments.

For **multi-instance deployments**, consider:
- Using Redis for distributed rate limiting
- Implementing at the nginx/load balancer level
- Using a dedicated rate limiting service

### Monitoring Rate Limits

To monitor rate limiting effectiveness:

1. **Log rate limit violations**:
   ```java
   // Add logging in RateLimitFilter
   logger.warn("Rate limit exceeded for IP: {}", clientIp);
   ```

2. **Track metrics**:
   - Number of rate-limited requests
   - IPs that are frequently banned
   - Peak request rates

3. **Alert on suspicious patterns**:
   - Sudden spikes in rate-limited requests
   - Same IP repeatedly hitting limits

## Troubleshooting

### Common Issues

**401 Unauthorized with valid token**:
- Check issuer claim matches `mp.jwt.verify.issuer`
- Verify public key matches the private key used for signing
- Ensure token is not expired

**403 Forbidden with valid token**:
- Verify user has the required role in `groups` claim
- Check role name matches exactly (case-sensitive)

**Token not being sent from Angular**:
- Verify user is authenticated (`authService.isAuthenticated()`)
- Check browser console for interceptor errors
- Ensure request URL starts with `/api/`

## References

- [Quarkus Security JWT Guide](https://quarkus.io/guides/security-jwt)
- [MicroProfile JWT RBAC Specification](https://github.com/eclipse/microprofile-jwt-auth)
- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [RFC 8725 - JWT Best Current Practices](https://tools.ietf.org/html/rfc8725)
